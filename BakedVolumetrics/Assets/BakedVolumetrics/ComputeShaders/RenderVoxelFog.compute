Texture2D<float4> Read;
RWTexture3D<float4> Write;

float3 VolumeResolution;
int layerIndex;

SamplerState _PointClamp;
SamplerState _LinearClamp;

struct LightDirectional
{
    float3 lightDirection;
    float3 lightColor;
    float3 lightIntensity;
};

struct LightPoint
{
    float3 lightPosition;
    float3 lightColor;
    float3 lightIntensity;
    float lightRange;
};

struct LightSpot
{
    float3 lightPosition;
    float3 lightDirection;
    float3 lightColor;
    float3 lightIntensity;
    float lightRange;
};

struct LightArea
{
    float3 lightPosition;
    float3 lightDirection;
    float2 lightSize;
    float3 lightColor;
    float3 lightIntensity;
    float lightRange;
};

RWStructuredBuffer<LightDirectional> DirectionalLights;
RWStructuredBuffer<LightPoint> PointLights;
RWStructuredBuffer<LightSpot> SpotLights;
RWStructuredBuffer<LightArea> AreaLights;

float4 TEX2D(Texture2D<float4> tex, float2 uv)
{
    return tex.SampleLevel(_LinearClamp, uv, 0);
}

#pragma kernel CSMain
[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint3 newIndex = uint3(id.x, id.y, layerIndex);

    float2 uv = id.xy + float2(0.5, 0.5);
    uv /= VolumeResolution.xy;

    float4 voxelSlice = TEX2D(Read, uv);

    Write[newIndex] = float4(voxelSlice.rgb, 0.0);

    //Write[newIndex] = float4(newIndex.x, newIndex.y, newIndex.z, 0.0);
}
